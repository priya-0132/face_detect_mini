from PyQt5 import QtWidgets, QtGui, QtCore
import sys
import os
import subprocess

class AttendanceApp(QtWidgets.QMainWindow):
    def __init__(self, user_role="user", username=""):
        super().__init__()
        self.user_role = user_role
        self.username = username
        self.initUI()

    def initUI(self):
        self.setWindowTitle("Face Recognition Attendance System")
        self.setGeometry(100, 100, 800, 600)
        self.setStyleSheet("background-color: #2C3E50;")

        central_widget = QtWidgets.QWidget(self)
        self.setCentralWidget(central_widget)
        layout = QtWidgets.QVBoxLayout(central_widget)
        layout.setAlignment(QtCore.Qt.AlignCenter)

        self.label = QtWidgets.QLabel(f"Welcome, {self.username}!", self)
        self.label.setFont(QtGui.QFont("Arial", 20, QtGui.QFont.Bold))
        self.label.setStyleSheet("color: #ECF0F1;")
        self.label.setAlignment(QtCore.Qt.AlignCenter)
        layout.addWidget(self.label)

        button_style = """
            QPushButton {
                background-color: #3498DB;
                color: white;
                border-radius: 10px;
                font-size: 18px;
                font-weight: bold;
                padding: 15px;
                min-width: 300px;
            }
            QPushButton:hover {
                background-color: #2980B9;
            }
        """

        self.buttons = [
            ("Mark Attendance", f"G:/attendence/mark_attendence.py {self.username}"),
            ("View Attendance List", f"G:/attendence/view_attendence_gui.py {self.username}"),
        ]

        if self.user_role == "admin":
            self.buttons += [
                ("Add Student", "G:/attendence/add_student_with_camera.py"),
                ("Update Record", "G:/attendence/update_record.py"),
                ("Update Face", "G:/attendence/update_face.py"),
                ("Delete Record", "G:/attendence/delete_record.py"),
            ]

        self.buttons.append(("Logout", "exit"))

        for text, command in self.buttons:
            btn = QtWidgets.QPushButton(text, self)
            btn.setStyleSheet(button_style)
            btn.clicked.connect(lambda checked, cmd=command: subprocess.Popen([sys.executable] + cmd.split(), shell=True) if cmd != "exit" else self.close())
            layout.addWidget(btn)

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    window = AttendanceApp(sys.argv[1], sys.argv[2])
    window.show()
    sys.exit(app.exec_())
























import cv2
import face_recognition
import pickle
import os
import mysql.connector

# ‚úÖ Connect to MySQL
conn = mysql.connector.connect(
    host="localhost",
    user="root",
    password="root",
    database="FaceRecognitionDB"
)
cursor = conn.cursor()

# ‚úÖ Load student images
folderPath = 'Images'
if not os.path.exists(folderPath):
    raise FileNotFoundError(f"Error: Folder '{folderPath}' not found!")

pathList = os.listdir(folderPath)
print("Images Found:", pathList)

imgList = []
studentIds = []

for path in pathList:
    img = cv2.imread(os.path.join(folderPath, path))
    if img is not None:
        imgList.append(img)
        studentIds.append(os.path.splitext(path)[0])

print("‚úÖ Images Loaded:", studentIds)

# ‚úÖ Function to find encodings
def findEncodings(imagesList):
    encodeList = []
    for img in imagesList:
        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
        encode = face_recognition.face_encodings(img)
        if encode:
            encodeList.append(encode[0])
    return encodeList

# ‚úÖ Generate face encodings
print("Encoding Started ...")
encodeListKnown = findEncodings(imgList)
encodeListKnownWithIds = [encodeListKnown, studentIds]
print("Encoding Complete")

# ‚úÖ Save encodings to file
with open("EncodeFile.p", 'wb') as file:
    pickle.dump(encodeListKnownWithIds, file)

print("‚úÖ Encoding file 'EncodeFile.p' saved successfully!")

cursor.close()
conn.close()

























from PyQt5 import QtWidgets, QtGui, QtCore
import mysql.connector
import os
import sys

class DeleteRecordWindow(QtWidgets.QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Delete Student Record")
        self.setGeometry(200, 200, 400, 300)
        self.setStyleSheet("background-color: #ECF0F1;")
        self.initUI()

    def initUI(self):
        layout = QtWidgets.QVBoxLayout()
        
        self.label = QtWidgets.QLabel("Enter Student Details for Deletion:")
        self.label.setFont(QtGui.QFont("Arial", 12))
        layout.addWidget(self.label)
        
        self.student_id_input1 = QtWidgets.QLineEdit()
        self.student_id_input1.setPlaceholderText("Enter Student ID")
        layout.addWidget(self.student_id_input1)
        
        self.student_id_input2 = QtWidgets.QLineEdit()
        self.student_id_input2.setPlaceholderText("Re-enter Student ID")
        layout.addWidget(self.student_id_input2)
        
        self.student_name_input = QtWidgets.QLineEdit()
        self.student_name_input.setPlaceholderText("Enter Student Name")
        layout.addWidget(self.student_name_input)
        
        self.warning_label = QtWidgets.QLabel("‚ö† WARNING: This action cannot be undone!")
        self.warning_label.setStyleSheet("color: red; font-weight: bold;")
        layout.addWidget(self.warning_label)
        
        self.delete_btn = QtWidgets.QPushButton("Delete Record")
        self.delete_btn.setStyleSheet("background-color: #E74C3C; color: white; padding: 10px; font-size: 14px;")
        self.delete_btn.clicked.connect(self.delete_record)
        layout.addWidget(self.delete_btn)
        
        self.result_label = QtWidgets.QLabel("")
        layout.addWidget(self.result_label)
        
        self.setLayout(layout)
    
    def delete_record(self):
        student_id1 = self.student_id_input1.text()
        student_id2 = self.student_id_input2.text()
        student_name = self.student_name_input.text()
        
        if not student_id1 or not student_id2 or not student_name:
            QtWidgets.QMessageBox.warning(self, "Error", "‚ö† All fields are required!")
            return
        
        if student_id1 != student_id2:
            QtWidgets.QMessageBox.warning(self, "Error", "‚ö† Student IDs do not match!")
            return
        
        try:
            conn = mysql.connector.connect(
                host="localhost",
                user="root",
                password="root",
                database="FaceRecognitionDB"
            )
            cursor = conn.cursor()
            cursor.execute("SELECT id, name FROM Students WHERE id = %s", (student_id1,))
            student = cursor.fetchone()
            
            if student and student[1] == student_name:
                confirm = QtWidgets.QMessageBox.question(self, "Confirm Deletion", 
                    "Are you sure you want to delete this record? This action cannot be undone!", 
                    QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No, QtWidgets.QMessageBox.No)
                
                if confirm == QtWidgets.QMessageBox.Yes:
                    cursor.execute("DELETE FROM Students WHERE id = %s", (student_id1,))
                    conn.commit()
                    
                    image_path = f"Images/{student_id1}.jpg"
                    encoding_path = f"Encodings/{student_id1}.p"
                    
                    if os.path.exists(image_path):
                        os.remove(image_path)
                    if os.path.exists(encoding_path):
                        os.remove(encoding_path)
                    
                    QtWidgets.QMessageBox.information(self, "Success", "‚úÖ Record Deleted Successfully!")
                else:
                    QtWidgets.QMessageBox.information(self, "Cancelled", "‚ö† Deletion Cancelled.")
            else:
                QtWidgets.QMessageBox.warning(self, "Error", "‚ö† Student ID or Name Incorrect!")
            
            cursor.close()
            conn.close()
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", f"‚ùå Error: {str(e)}")

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    window = DeleteRecordWindow()
    window.show()
    sys.exit(app.exec_())
































import mysql.connector
import os
from tkinter import simpledialog, Tk

# ‚úÖ Connect to MySQL
conn = mysql.connector.connect(
    host="localhost",
    user="root",
    password="root",
    database="FaceRecognitionDB"
)
cursor = conn.cursor()

# ‚úÖ Prompt for Student ID
root = Tk()
root.withdraw()
student_id = simpledialog.askstring("Input", "Enter Student ID to delete:", parent=root)

if student_id:
    cursor.execute("SELECT id FROM Students WHERE id = %s", (student_id,))
    student = cursor.fetchone()

    if student:
        confirm = simpledialog.askstring("Confirm", "Type 'DELETE' to confirm:", parent=root)

        if confirm == "DELETE":
            # ‚úÖ Delete from MySQL
            cursor.execute("DELETE FROM Students WHERE id = %s", (student_id,))
            conn.commit()
            print("‚úÖ Student record deleted from database!")

            # ‚úÖ Remove Image & Encoding
            image_path = f"Images/{student_id}.jpg"
            encoding_path = f"Encodings/{student_id}.p"

            if os.path.exists(image_path):
                os.remove(image_path)
                print("‚úÖ Image file deleted!")

            if os.path.exists(encoding_path):
                os.remove(encoding_path)
                print("‚úÖ Encoding file deleted!")

        else:
            print("‚ö† Deletion cancelled.")

    else:
        print("‚ö† Student ID not found.")

cursor.close()
conn.close()







import mysql.connector
import sys
import tkinter as tk
from tkinter import ttk, messagebox

class ViewAttendanceApp:
    def __init__(self, root, role="user", username=None):
        """Initialize Attendance Viewer GUI"""
        print("üîÑ Initializing Attendance GUI...")
        self.root = root
        self.role = role
        self.username = username  

        self.root.title("View Attendance Records")
        self.root.geometry("1000x500")
        self.root.configure(bg="#ECF0F1")

        title_label = tk.Label(self.root, text="Attendance Records", font=("Arial", 16, "bold"), bg="#ECF0F1")
        title_label.pack(pady=10)

        self.tree = ttk.Treeview(self.root, columns=("Username", "Total Attendance"), show='headings')
        self.tree.heading("Username", text="Username")
        self.tree.heading("Total Attendance", text="Total Attendance")

        self.tree.column("Username", width=200)
        self.tree.column("Total Attendance", width=150)

        self.tree.pack(pady=20, fill=tk.BOTH, expand=True)

        self.load_attendance()

    def load_attendance(self):
        """Load Attendance Data from Database"""
        print("üîÑ Connecting to Database...")  
        try:
            conn = mysql.connector.connect(
                host="localhost",
                user="root",
                password="root",
                database="FaceRecognitionDB"
            )
            cursor = conn.cursor()

            if self.role == "admin":
                cursor.execute("SELECT username, total_attendance FROM users")
            else:
                if not self.username:
                    messagebox.showwarning("Error", "‚ö† No username provided for the user role!")
                    return

                cursor.execute("SELECT username, total_attendance FROM users WHERE username = %s", (self.username,))
            
            records = cursor.fetchall()
            print(f"‚úÖ Retrieved {len(records)} records from database.")

            if not records:
                messagebox.showinfo("Info", "‚ö† No attendance records found.")
                return

            for record in records:
                self.tree.insert("", tk.END, values=record)

            cursor.close()
            conn.close()
        except mysql.connector.Error as e:
            messagebox.showerror("Database Error", f"‚ùå {str(e)}")

if __name__ == "__main__":
    print("üöÄ Starting View Attendance GUI...")  

    role = sys.argv[1] if len(sys.argv) > 1 else "admin"
    username = sys.argv[2] if len(sys.argv) > 2 else None  # ‚úÖ Get username

    root = tk.Tk()
    app = ViewAttendanceApp(root, role, username)
    root.mainloop()












import mysql.connector
import sys
import tkinter as tk
from tkinter import ttk, messagebox

class ViewAttendanceApp:
    def __init__(self, root, role="user", username=None):
        """Initialize Attendance Viewer GUI"""
        print("üîÑ Initializing Attendance GUI...")
        self.root = root
        self.role = role
        self.username = username  

        self.root.title("View Attendance Records")
        self.root.geometry("1000x500")
        self.root.configure(bg="#ECF0F1")

        title_label = tk.Label(self.root, text="Attendance Records", font=("Arial", 16, "bold"), bg="#ECF0F1")
        title_label.pack(pady=10)

        self.tree = ttk.Treeview(self.root, columns=("Username", "Total Attendance"), show='headings')
        self.tree.heading("Username", text="Username")
        self.tree.heading("Total Attendance", text="Total Attendance")

        self.tree.column("Username", width=200)
        self.tree.column("Total Attendance", width=150)

        self.tree.pack(pady=20, fill=tk.BOTH, expand=True)

        self.load_attendance()

    def load_attendance(self):
        """Load Attendance Data from Database"""
        print("üîÑ Connecting to Database...")  
        try:
            conn = mysql.connector.connect(
                host="localhost",
                user="root",
                password="root",
                database="FaceRecognitionDB"
            )
            cursor = conn.cursor()

            if self.role == "admin":
                cursor.execute("SELECT username, total_attendance FROM users")
            else:
                if not self.username:
                    messagebox.showwarning("Error", "‚ö† No username provided for the user role!")
                    return

                cursor.execute("SELECT username, total_attendance FROM users WHERE username = %s", (self.username,))
            
            records = cursor.fetchall()
            print(f"‚úÖ Retrieved {len(records)} records from database.")

            if not records:
                messagebox.showinfo("Info", "‚ö† No attendance records found.")
                return

            for record in records:
                self.tree.insert("", tk.END, values=record)

            cursor.close()
            conn.close()
        except mysql.connector.Error as e:
            messagebox.showerror("Database Error", f"‚ùå {str(e)}")

if __name__ == "__main__":
    print("üöÄ Starting View Attendance GUI...")  

    role = sys.argv[1] if len(sys.argv) > 1 else "admin"
    username = sys.argv[2] if len(sys.argv) > 2 else None  # ‚úÖ Get username

    root = tk.Tk()
    app = ViewAttendanceApp(root, role, username)
    root.mainloop()




import mysql.connector
import tkinter as tk
from tkinter import messagebox, simpledialog
import subprocess
from send_otp import send_otp  # ‚úÖ Import OTP Module
import cv2
import face_recognition
import numpy as np
import os

class UserManagementApp:
    def __init__(self, root):
        self.root = root
        self.root.title("User Management")
        self.root.geometry("400x400")

        self.initUI()

    def initUI(self):
        tk.Label(self.root, text="Face Recognition System", font=("Arial", 14, "bold")).pack(pady=10)

        tk.Label(self.root, text="Username:").pack()
        self.entry_username = tk.Entry(self.root)
        self.entry_username.pack()

        tk.Label(self.root, text="Password:").pack()
        self.entry_password = tk.Entry(self.root, show="*")
        self.entry_password.pack()

        tk.Button(self.root, text="üîë Login", command=self.login).pack(pady=5)
        tk.Button(self.root, text="üì∑ Login with Face", command=self.login_with_face).pack(pady=5)
        tk.Button(self.root, text="üÜï Create New User", command=self.create_user).pack(pady=5)
        tk.Button(self.root, text="üîÑ Reset Password", command=self.reset_password).pack(pady=5)

    def login(self):
        username = self.entry_username.get()
        password = self.entry_password.get()

        if not username or not password:
            messagebox.showwarning("‚ö† Error", "Username and password are required!")
            return

        try:
            conn = mysql.connector.connect(host="localhost", user="root", password="root", database="FaceRecognitionDB")
            cursor = conn.cursor()
            cursor.execute("SELECT email, role FROM users WHERE username = %s AND password = %s", (username, password))
            user = cursor.fetchone()
            cursor.close()
            conn.close()

            if user:
                email, role = user

                messagebox.showinfo("‚úÖ Success", "Login Successful!")
                self.root.destroy()  # Close login window
                
                # ‚úÖ Open GUI with Role-Based Access
                subprocess.Popen(["python", "G:/attendence/GUI.py", role])
            else:
                messagebox.showerror("‚ùå Error", "Invalid Username or Password!")
        except Exception as e:
            messagebox.showerror("‚ùå Error", f"Database Error: {str(e)}")

    def login_with_face(self):
        """üîµ Face Recognition Login"""
        known_encodings = []
        known_usernames = []

        try:
            conn = mysql.connector.connect(host="localhost", user="root", password="root", database="FaceRecognitionDB")
            cursor = conn.cursor()
            cursor.execute("SELECT username FROM users")
            users = cursor.fetchall()
            cursor.close()
            conn.close()

            if not users:
                messagebox.showwarning("‚ö† Error", "No users registered for face recognition.")
                return

            for user in users:
                username = user[0]
                image_path = f"Encodings/{username}.p"  # üîπ Ensure face images are stored in this path
                if os.path.exists(image_path):
                    img = face_recognition.load_image_file(image_path)
                    encoding = face_recognition.face_encodings(img)
                    if encoding:
                        known_encodings.append(encoding[0])
                        known_usernames.append(username)

            if not known_encodings:
                messagebox.showerror("‚ùå Error", "No valid face encodings found.")
                return

            # Capture Image from Webcam
            cap = cv2.VideoCapture(0)
            messagebox.showinfo("üîç Face Recognition", "Looking for your face...")

            while True:
                ret, frame = cap.read()
                if not ret:
                    break

                small_frame = cv2.resize(frame, (0, 0), fx=0.25, fy=0.25)
                rgb_frame = cv2.cvtColor(small_frame, cv2.COLOR_BGR2RGB)
                face_locations = face_recognition.face_locations(rgb_frame)
                face_encodings = face_recognition.face_encodings(rgb_frame, face_locations)

                for encoding in face_encodings:
                    matches = face_recognition.compare_faces(known_encodings, encoding, tolerance=0.5)
                    if True in matches:
                        matched_idx = matches.index(True)
                        username = known_usernames[matched_idx]
                        cap.release()
                        cv2.destroyAllWindows()
                        messagebox.showinfo("‚úÖ Success", f"Welcome {username}!")
                        self.root.destroy()
                        subprocess.Popen(["python", "G:/attendence/GUI.py", username])
                        return

            cap.release()
            cv2.destroyAllWindows()
            messagebox.showerror("‚ùå Error", "Face Not Recognized!")
        except Exception as e:
            messagebox.showerror("‚ö† Error", f"Face Login Error: {str(e)}")

    def create_user(self):
        new_username = simpledialog.askstring("Create User", "Enter New Username:")
        new_password = simpledialog.askstring("Create User", "Enter New Password:")
        email = simpledialog.askstring("Create User", "Enter Email:")

        role = "user"  # ‚úÖ Default Role

        if not new_username or not new_password or not email:
            messagebox.showwarning("‚ö† Error", "All fields are required!")
            return

        try:
            conn = mysql.connector.connect(host="localhost", user="root", password="root", database="FaceRecognitionDB")
            cursor = conn.cursor()
            cursor.execute("INSERT INTO users (username, password, email, role) VALUES (%s, %s, %s, %s)", 
                           (new_username, new_password, email, role))
            conn.commit()
            cursor.close()
            conn.close()
            messagebox.showinfo("‚úÖ Success", "User Created Successfully!")
        except mysql.connector.Error as err:
            messagebox.showerror("‚ùå Error", f"Database Error: {str(err)}")

    def reset_password(self):
        username = simpledialog.askstring("Reset Password", "Enter Your Username:")
        if not username:
            messagebox.showwarning("‚ö† Error", "Username is required!")
            return

        try:
            conn = mysql.connector.connect(host="localhost", user="root", password="root", database="FaceRecognitionDB")
            cursor = conn.cursor()
            cursor.execute("SELECT email FROM users WHERE username = %s", (username,))
            user = cursor.fetchone()
            cursor.close()
            conn.close()

            if not user:
                messagebox.showwarning("‚ö† Error", "Username Not Found!")
                return

            email = user[0]
            sent_otp = send_otp(email)
            entered_otp = simpledialog.askstring("OTP Verification", "Enter the OTP sent to your email:")
            if entered_otp != sent_otp:
                messagebox.showerror("‚ùå Error", "Invalid OTP!")
                return

            new_password = simpledialog.askstring("Reset Password", "Enter New Password:")
            if not new_password:
                messagebox.showwarning("‚ö† Error", "New password is required!")
                return

            conn = mysql.connector.connect(host="localhost", user="root", password="root", database="FaceRecognitionDB")
            cursor = conn.cursor()
            cursor.execute("UPDATE users SET password = %s WHERE username = %s", (new_password, username))
            conn.commit()
            cursor.close()
            conn.close()
            messagebox.showinfo("‚úÖ Success", "Password Reset Successfully!")
        except Exception as e:
            messagebox.showerror("‚ùå Error", f"Database Error: {str(e)}")

if __name__ == "__main__":
    root = tk.Tk()
    app = UserManagementApp(root)
    root.mainloop()









import mysql.connector
import cv2
import face_recognition
import pickle
import numpy as np
from datetime import datetime
import os
import subprocess
import tkinter as tk
from tkinter import messagebox

# ‚úÖ Connect to MySQL
conn = mysql.connector.connect(
    host="localhost",
    user="root",
    password="root",
    database="FaceRecognitionDB"
)
cursor = conn.cursor()

# ‚úÖ Load All Stored Face Encodings
encoding_folder = "Encodings"
if not os.path.exists(encoding_folder):
    os.makedirs(encoding_folder)

encodeListKnown = []
studentUsernames = []

print("üîÑ Loading All Stored Encodings ...")
for filename in os.listdir(encoding_folder):
    if filename.endswith(".p"):
        username = filename.split(".")[0]
        with open(os.path.join(encoding_folder, filename), 'rb') as file:
            encode = pickle.load(file)
        encodeListKnown.append(encode)
        studentUsernames.append(username)

print(f"‚úÖ Loaded {len(encodeListKnown)} Encoded Faces")

# ‚úÖ Open Webcam
cap = cv2.VideoCapture(0)
cap.set(3, 640)
cap.set(4, 480)

face_detected = False
attendance_marked = False
start_time = datetime.now()

while True:
    success, img = cap.read()
    imgS = cv2.resize(img, (0, 0), None, 0.25, 0.25)
    imgS = cv2.cvtColor(imgS, cv2.COLOR_BGR2RGB)

    faceCurFrame = face_recognition.face_locations(imgS)
    encodeCurFrame = face_recognition.face_encodings(imgS, faceCurFrame)

    elapsed_time = (datetime.now() - start_time).total_seconds()
    if elapsed_time > 7:
        break  # ‚úÖ Close camera if no face detected for 7 seconds

    if faceCurFrame:
        face_detected = True

        for encodeFace, faceLoc in zip(encodeCurFrame, faceCurFrame):
            matches = face_recognition.compare_faces(encodeListKnown, encodeFace)
            faceDis = face_recognition.face_distance(encodeListKnown, encodeFace)
            matchIndex = np.argmin(faceDis) if faceDis.size > 0 else None

            if matchIndex is not None and matches[matchIndex]:
                username = studentUsernames[matchIndex]

                # ‚úÖ Fetch User Info from MySQL
                cursor.execute("SELECT username, email, total_attendance FROM users WHERE username = %s", (username,))
                userInfo = cursor.fetchone()

                if userInfo:
                    username, email, total_attendance = userInfo

                    # ‚úÖ Update Attendance in MySQL
                    cursor.execute("""
                        UPDATE users 
                        SET total_attendance = total_attendance + 1, last_attendance_time = %s 
                        WHERE username = %s
                    """, (datetime.now(), username))
                    conn.commit()

                    # ‚úÖ Draw Green Circle & Show Username
                    y1, x2, y2, x1 = faceLoc
                    y1, x2, y2, x1 = y1 * 4, x2 * 4, y2 * 4, x1 * 4
                    center_x, center_y = (x1 + x2) // 2, (y1 + y2) // 2
                    radius = (x2 - x1) // 2

                    cv2.circle(img, (center_x, center_y), radius, (0, 255, 0), 4)
                    cv2.putText(img, f"Username: {username}", (x1, y1 - 30), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 0), 2)
                    cv2.putText(img, "Attendance Marked!", (x1, y1 - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 0), 2)

                    cv2.imshow("Face Attendance", img)
                    cv2.waitKey(2000)  # ‚úÖ Show for 2 seconds before closing
                    attendance_marked = True
                    break
            else:
                cv2.putText(img, "‚ùå Face Not Recognized!", (50, 50), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2)

    cv2.imshow("Face Attendance", img)

    if attendance_marked or (cv2.waitKey(1) & 0xFF == ord('q')):
        break

# ‚úÖ If No Known Face Found, Ask to Add New Student
if not attendance_marked:
    root = tk.Tk()
    root.withdraw()
    result = messagebox.askyesno("No Record Found", "No matching user found. Do you want to register?")
    if result:
        subprocess.Popen(["python", "G:/attendence/add_student_with_camera.py"])

cap.release()
cv2.destroyAllWindows()
cursor.close()
conn.close()











import smtplib
import random
import time
import tkinter as tk
from threading import Thread

# ‚úÖ Store OTPs temporarily (email -> OTP, timestamp)
otp_storage = {}

def send_otp(email):
    """‚úÖ Send OTP to the given email and store it with a timestamp."""
    otp = str(random.randint(100000, 999999))  # Generate 6-digit OTP

    sender_email = "snscollege845401@gmail.com"  # Replace with your email
    sender_password = "pxfyilnmpoyzawzj"  # ‚úÖ Use App Password

    subject = "Your OTP for Face Recognition System"
    message = f"Your OTP is: {otp}\n\nThis OTP is valid for 1 minute."

    try:
        server = smtplib.SMTP("smtp.gmail.com", 587)
        server.starttls()
        server.login(sender_email, sender_password)
        server.sendmail(sender_email, email, f"Subject: {subject}\n\n{message}")
        server.quit()

        # ‚úÖ Store OTP with timestamp
        otp_storage[email] = {"otp": otp, "timestamp": time.time()}
        print(f"‚úÖ OTP Sent to {email}")
        return otp  # ‚úÖ Return OTP for verification
    except Exception as e:
        print(f"Email Error: {e}")
        return None

def verify_otp(email, entered_otp):
    """‚úÖ Verify if the entered OTP is correct and not expired (valid for 1 min)."""
    if email not in otp_storage:
        return False  # No OTP sent

    otp_data = otp_storage[email]
    current_time = time.time()

    # ‚úÖ Check if OTP is correct and within 60 seconds
    if otp_data["otp"] == entered_otp and (current_time - otp_data["timestamp"]) <= 60:
        return True  # ‚úÖ OTP is valid
    return False  # ‚ùå OTP expired or incorrect

# ‚úÖ Tkinter GUI for OTP Verification with Resend Option
class OTPVerificationApp:
    def __init__(self, root, email):
        self.root = root
        self.email = email
        self.root.title("OTP Verification")
        self.root.geometry("400x300")

        self.otp_label = tk.Label(root, text="Enter the OTP sent to your email:", font=("Arial", 12))
        self.otp_label.pack(pady=10)

        self.otp_entry = tk.Entry(root, font=("Arial", 14))
        self.otp_entry.pack(pady=10)

        self.verify_button = tk.Button(root, text="Verify OTP", font=("Arial", 12), command=self.verify_otp)
        self.verify_button.pack(pady=5)

        # ‚úÖ Resend OTP Button (Initially Disabled)
        self.resend_button = tk.Button(root, text="Resend OTP (Wait 30s)", font=("Arial", 12), state=tk.DISABLED, command=self.resend_otp)
        self.resend_button.pack(pady=5)

        # ‚úÖ Start Timer for Resend OTP Button
        self.start_resend_timer()

    def verify_otp(self):
        entered_otp = self.otp_entry.get()
        if verify_otp(self.email, entered_otp):
            tk.messagebox.showinfo("Success", "‚úÖ OTP Verified Successfully!")
            self.root.destroy()  # ‚úÖ Close OTP window after successful verification
        else:
            tk.messagebox.showerror("Error", "‚ùå Invalid or Expired OTP. Try Again.")

    def resend_otp(self):
        """‚úÖ Resend OTP and reset the timer."""
        send_otp(self.email)
        self.resend_button.config(text="Resend OTP (Wait 30s)", state=tk.DISABLED)
        self.start_resend_timer()  # Restart 30s Timer

    def start_resend_timer(self):
        """‚úÖ Enable Resend Button after 30 Seconds."""
        def enable_button():
            time.sleep(30)  # Wait for 30 seconds
            self.resend_button.config(text="Resend OTP", state=tk.NORMAL)

        # Run in a separate thread to avoid freezing UI
        Thread(target=enable_button, daemon=True).start()

# ‚úÖ Example Usage:
if __name__ == "__main__":
    root = tk.Tk()
    email = "test@example.com"  # Replace with actual email input from user
    send_otp(email)  # ‚úÖ Send OTP initially
    app = OTPVerificationApp(root, email)
    root.mainloop()





import cv2
import mysql.connector
import os
import pickle
import face_recognition
import sys
import tkinter as tk
from tkinter import messagebox

# ‚úÖ Ensure Username is Provided
if len(sys.argv) != 2:
    print("‚ö† Error: Missing Username. Usage: update_face.py <username>")
    sys.exit(1)

username = sys.argv[1]

# ‚úÖ Connect to MySQL
try:
    conn = mysql.connector.connect(
        host="localhost",
        user="root",
        password="root",
        database="FaceRecognitionDB"
    )
    cursor = conn.cursor()
    cursor.execute("SELECT username FROM users WHERE username = %s", (username,))
    user = cursor.fetchone()

    if not user:
        print("‚ö† Username Not Found!")
        messagebox.showwarning("Error", "‚ö† Username Not Found in Database!")
        sys.exit(1)
except Exception as e:
    print(f"‚ùå Database Connection Error: {str(e)}")
    messagebox.showerror("Database Error", f"‚ùå {str(e)}")
    sys.exit(1)

# ‚úÖ Open Webcam to Capture New Image
cap = cv2.VideoCapture(0)
cap.set(3, 640)
cap.set(4, 480)

print("üì∑ Press 'SPACE' to capture a new image or 'ESC' to exit.")
while True:
    success, img = cap.read()
    cv2.imshow("Update Face", img)
    key = cv2.waitKey(1)

    if key == 27:  # ESC key to exit
        cap.release()
        cv2.destroyAllWindows()
        sys.exit(0)

    elif key == 32:  # SPACE key to capture
        cap.release()
        cv2.destroyAllWindows()
        
        # ‚úÖ Save New Image
        image_folder = "Images"
        encoding_folder = "Encodings"
        os.makedirs(image_folder, exist_ok=True)
        os.makedirs(encoding_folder, exist_ok=True)
        
        image_path = f"{image_folder}/{username}.jpg"
        cv2.imwrite(image_path, img)
        
        # ‚úÖ Generate New Face Encoding
        img_user = face_recognition.load_image_file(image_path)
        face_locations = face_recognition.face_locations(img_user)

        if face_locations:
            encode = face_recognition.face_encodings(img_user, face_locations)[0]
            encoding_path = f"{encoding_folder}/{username}.p"
            with open(encoding_path, 'wb') as file:
                pickle.dump(encode, file)
            
            print("‚úÖ Face Updated Successfully!")
            messagebox.showinfo("Success", "‚úÖ Face Updated Successfully!")
        else:
            os.remove(image_path)
            print("‚ö† No face detected. Please try again.")
            messagebox.showwarning("Error", "‚ö† No face detected. Please try again.")
        break

cursor.close()
conn.close()














from PyQt5 import QtWidgets, QtGui, QtCore
import cv2
import mysql.connector
import os
import pickle
import face_recognition
import sys

class UpdateFaceWindow(QtWidgets.QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Update Student Face")
        self.setGeometry(200, 200, 400, 250)
        self.setStyleSheet("background-color: #ECF0F1;")
        self.initUI()

    def initUI(self):
        layout = QtWidgets.QVBoxLayout()
        
        self.label = QtWidgets.QLabel("Enter Username to Update Face:")
        self.label.setFont(QtGui.QFont("Arial", 12))
        layout.addWidget(self.label)
        
        self.student_id_input = QtWidgets.QLineEdit()
        self.student_id_input.setPlaceholderText("Username")
        layout.addWidget(self.student_id_input)
        
        self.update_btn = QtWidgets.QPushButton("Update Face")
        self.update_btn.setStyleSheet("background-color: #3498DB; color: white; padding: 10px; font-size: 14px;")
        self.update_btn.clicked.connect(self.update_face)
        layout.addWidget(self.update_btn)
        
        self.result_label = QtWidgets.QLabel("")
        layout.addWidget(self.result_label)
        
        self.setLayout(layout)
    
    def update_face(self):
        username = self.student_id_input.text().strip()
        
        if not username:
            self.result_label.setText("‚ö† Username is required!")
            return
        
        # ‚úÖ Connect to Database
        conn = mysql.connector.connect(
            host="localhost",
            user="root",
            password="root",
            database="FaceRecognitionDB"
        )
        cursor = conn.cursor()
        
        # ‚úÖ Check if user exists
        cursor.execute("SELECT username FROM users WHERE username = %s", (username,))
        student = cursor.fetchone()
        
        if not student:
            self.result_label.setText("‚ö† Username Not Found!")
            cursor.close()
            conn.close()
            return
        
        # ‚úÖ Open Webcam to Capture New Image
        cap = cv2.VideoCapture(0)
        cap.set(3, 640)
        cap.set(4, 480)

        print("üì∑ Press 'SPACE' to capture a new image or 'ESC' to exit.")
        while True:
            success, img = cap.read()
            cv2.imshow("Update Face", img)
            key = cv2.waitKey(1)

            if key == 27:  # ESC key to exit
                cap.release()
                cv2.destroyAllWindows()
                return
            
            elif key == 32:  # SPACE key to capture
                cap.release()
                cv2.destroyAllWindows()
                
                # ‚úÖ Save New Image
                image_folder = "Images"
                encoding_folder = "Encodings"
                os.makedirs(image_folder, exist_ok=True)
                os.makedirs(encoding_folder, exist_ok=True)
                
                image_path = f"{image_folder}/{username}.jpg"
                cv2.imwrite(image_path, img)
                
                # ‚úÖ Generate New Face Encoding
                img_student = face_recognition.load_image_file(image_path)
                face_locations = face_recognition.face_locations(img_student)
                if face_locations:
                    encode = face_recognition.face_encodings(img_student, face_locations)[0]
                    encoding_path = f"{encoding_folder}/{username}.p"
                    with open(encoding_path, 'wb') as file:
                        pickle.dump(encode, file)
                    self.result_label.setText("‚úÖ Face Updated Successfully!")
                else:
                    os.remove(image_path)
                    self.result_label.setText("‚ö† No face detected. Please try again.")
                break
        
        cursor.close()
        conn.close()

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    window = UpdateFaceWindow()
    window.show()
    sys.exit(app.exec_())








import mysql.connector
import tkinter as tk
from tkinter import messagebox, simpledialog
import sys

def update_record():
    root = tk.Tk()
    root.withdraw()

    # ‚úÖ Take Username from Command-Line Argument
    username = sys.argv[1] if len(sys.argv) > 1 else simpledialog.askstring("Update Record", "Enter Username to update:")

    if not username:
        messagebox.showwarning("Error", "‚ö† Username is required!")
        return
    
    try:
        conn = mysql.connector.connect(
            host="localhost",
            user="root",
            password="root",
            database="FaceRecognitionDB"
        )
        cursor = conn.cursor()
        cursor.execute("SELECT username, name, email, role, total_attendance FROM users WHERE username = %s", (username,))
        user = cursor.fetchone()
        cursor.close()
        conn.close()
        
        if not user:
            messagebox.showwarning("Error", "‚ö† Username Not Found!")
            return
    except Exception as e:
        messagebox.showerror("Error", f"Database Error: {str(e)}")
        return
    
    edit_window = tk.Toplevel()
    edit_window.title("Update User Record")
    edit_window.geometry("400x400")

    labels = ["Username", "Name", "Email", "Role", "Total Attendance"]
    entries = {}
    original_values = list(user)  # Store original values for reset

    for idx, label in enumerate(labels):
        tk.Label(edit_window, text=label).grid(row=idx, column=0, padx=10, pady=5)
        entry = tk.Entry(edit_window)
        entry.insert(0, user[idx] if user[idx] is not None else "")  # ‚úÖ Handle NULL values
        entry.grid(row=idx, column=1, padx=10, pady=5)
        entries[label] = entry

    # ‚úÖ Prevent username editing (must remain unique)
    entries["Username"].config(state="disabled")

    # ‚úÖ Prevent role editing if user is not admin
    if user[3] == "user":
        entries["Role"].config(state="disabled")

    def save_changes():
        updated_values = [entries[label].get() for label in labels[1:]]  # Exclude username
        try:
            conn = mysql.connector.connect(
                host="localhost",
                user="root",
                password="root",
                database="FaceRecognitionDB"
            )
            cursor = conn.cursor()
            cursor.execute("""
                UPDATE users SET name=%s, email=%s, role=%s, total_attendance=%s WHERE username=%s
            """, updated_values + [username])  # ‚úÖ Don't update `username`
            conn.commit()
            cursor.close()
            conn.close()
            messagebox.showinfo("Success", "‚úÖ User record updated successfully!")
            edit_window.destroy()
        except Exception as e:
            messagebox.showerror("Error", f"Database Error: {str(e)}")

    def reset_fields():
        for idx, label in enumerate(labels[1:]):  # Exclude username
            entries[label].delete(0, tk.END)
            entries[label].insert(0, original_values[idx + 1] if original_values[idx + 1] is not None else "")

    save_button = tk.Button(edit_window, text="Save Changes", command=save_changes)
    save_button.grid(row=len(labels), column=0, pady=10)

    reset_button = tk.Button(edit_window, text="Reset", command=reset_fields)
    reset_button.grid(row=len(labels), column=1, pady=10)

    edit_window.mainloop()

if __name__ == "__main__":
    update_record()













from PyQt5 import QtWidgets, QtGui, QtCore
import mysql.connector
import sys

class UpdateRecordWindow(QtWidgets.QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Update User Record")
        self.setGeometry(200, 200, 400, 300)
        self.setStyleSheet("background-color: #ECF0F1;")
        self.initUI()

    def initUI(self):
        layout = QtWidgets.QVBoxLayout()

        self.label = QtWidgets.QLabel("Enter Username to Update:")
        self.label.setFont(QtGui.QFont("Arial", 12))
        layout.addWidget(self.label)

        self.username_input = QtWidgets.QLineEdit()
        self.username_input.setPlaceholderText("Username")
        layout.addWidget(self.username_input)

        self.new_name_input = QtWidgets.QLineEdit()
        self.new_name_input.setPlaceholderText("New Name")
        layout.addWidget(self.new_name_input)

        self.new_email_input = QtWidgets.QLineEdit()
        self.new_email_input.setPlaceholderText("New Email")
        layout.addWidget(self.new_email_input)

        self.new_role_input = QtWidgets.QComboBox()
        self.new_role_input.addItems(["user", "admin"])
        layout.addWidget(self.new_role_input)

        self.update_btn = QtWidgets.QPushButton("Update Record")
        self.update_btn.setStyleSheet("background-color: #3498DB; color: white; padding: 10px; font-size: 14px;")
        self.update_btn.clicked.connect(self.update_record)
        layout.addWidget(self.update_btn)

        self.result_label = QtWidgets.QLabel("")
        layout.addWidget(self.result_label)

        self.setLayout(layout)

    def update_record(self):
        username = self.username_input.text()
        new_name = self.new_name_input.text()
        new_email = self.new_email_input.text()
        new_role = self.new_role_input.currentText()

        if not username or not new_name or not new_email:
            self.result_label.setText("‚ö† All fields are required!")
            return

        try:
            conn = mysql.connector.connect(
                host="localhost",
                user="root",
                password="root",
                database="FaceRecognitionDB"
            )
            cursor = conn.cursor()
            cursor.execute("SELECT username FROM users WHERE username = %s", (username,))
            user = cursor.fetchone()

            if user:
                cursor.execute("""
                    UPDATE users 
                    SET name = %s, email = %s, role = %s 
                    WHERE username = %s
                """, (new_name, new_email, new_role, username))
                conn.commit()
                self.result_label.setText("‚úÖ Record Updated Successfully!")
            else:
                self.result_label.setText("‚ö† Username Not Found!")

            cursor.close()
            conn.close()
        except Exception as e:
            self.result_label.setText(f"‚ùå Error: {str(e)}")

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    window = UpdateRecordWindow()
    window.show()
    sys.exit(app.exec_())




import mysql.connector
import tkinter as tk
from tkinter import messagebox, simpledialog
import subprocess
from send_otp import send_otp  # ‚úÖ Import OTP Module

class UserManagementApp:
    def __init__(self, root):
        self.root = root
        self.root.title("User Management")
        self.root.geometry("400x350")

        self.initUI()

    def initUI(self):
        tk.Label(self.root, text="Face Recognition System", font=("Arial", 14, "bold")).pack(pady=10)

        tk.Label(self.root, text="Username:").pack()
        self.entry_username = tk.Entry(self.root)
        self.entry_username.pack()

        tk.Label(self.root, text="Password:").pack()
        self.entry_password = tk.Entry(self.root, show="*")
        self.entry_password.pack()

        tk.Button(self.root, text="Login", command=self.login).pack(pady=5)
        tk.Button(self.root, text="Create New User", command=self.create_user).pack(pady=5)
        tk.Button(self.root, text="Reset Password", command=self.reset_password).pack(pady=5)

    def login(self):
        username = self.entry_username.get()
        password = self.entry_password.get()

        if not username or not password:
            messagebox.showwarning("Error", "‚ö† Username and password are required!")
            return

        try:
            conn = mysql.connector.connect(host="localhost", user="root", password="root", database="FaceRecognitionDB")
            cursor = conn.cursor()
            cursor.execute("SELECT email, role FROM users WHERE username = %s AND password = %s", (username, password))
            user = cursor.fetchone()
            cursor.close()
            conn.close()

            if user:
                email, role = user

                messagebox.showinfo("Success", "‚úÖ Login Successful!")
                self.root.destroy()  # Close login window
                
                # ‚úÖ Open GUI with Role-Based Access
                subprocess.Popen(["python", "G:/attendence/GUI.py", role])
            else:
                messagebox.showerror("Error", "‚ùå Invalid Username or Password!")
        except Exception as e:
            messagebox.showerror("Error", f"Database Error: {str(e)}")

    def create_user(self):
        new_username = simpledialog.askstring("Create User", "Enter New Username:")
        new_password = simpledialog.askstring("Create User", "Enter New Password:")
        email = simpledialog.askstring("Create User", "Enter Email:")
        
        role = "user"  # ‚úÖ Always assign "user" role

        if not new_username or not new_password or not email:
            messagebox.showwarning("Error", "‚ö† All fields are required!")
            return

        try:
            conn = mysql.connector.connect(host="localhost", user="root", password="root", database="FaceRecognitionDB")
            cursor = conn.cursor()
            cursor.execute("INSERT INTO users (username, password, email, role) VALUES (%s, %s, %s, %s)", 
                           (new_username, new_password, email, role))
            conn.commit()
            cursor.close()
            conn.close()
            messagebox.showinfo("Success", "‚úÖ User Created Successfully!")
        except mysql.connector.Error as err:
            messagebox.showerror("Error", f"Database Error: {str(err)}")

    def reset_password(self):
        username = simpledialog.askstring("Reset Password", "Enter Your Username:")
        if not username:
            messagebox.showwarning("Error", "‚ö† Username is required!")
            return

        try:
            conn = mysql.connector.connect(host="localhost", user="root", password="root", database="FaceRecognitionDB")
            cursor = conn.cursor()
            cursor.execute("SELECT email FROM users WHERE username = %s", (username,))
            user = cursor.fetchone()
            cursor.close()
            conn.close()

            if not user:
                messagebox.showwarning("Error", "‚ö† Username Not Found!")
                return
            
            email = user[0]
            sent_otp = send_otp(email)
            entered_otp = simpledialog.askstring("OTP Verification", "Enter the OTP sent to your email:")
            if entered_otp != sent_otp:
                messagebox.showerror("Error", "‚ùå Invalid OTP!")
                return

            new_password = simpledialog.askstring("Reset Password", "Enter New Password:")
            if not new_password:
                messagebox.showwarning("Error", "‚ö† New password is required!")
                return

            conn = mysql.connector.connect(host="localhost", user="root", password="root", database="FaceRecognitionDB")
            cursor = conn.cursor()
            cursor.execute("UPDATE users SET password = %s WHERE username = %s", (new_password, username))
            conn.commit()
            cursor.close()
            conn.close()
            messagebox.showinfo("Success", "‚úÖ Password Reset Successfully!")
        except Exception as e:
            messagebox.showerror("Error", f"Database Error: {str(e)}")

if __name__ == "__main__":
    root = tk.Tk()
    app = UserManagementApp(root)
    root.mainloop()

